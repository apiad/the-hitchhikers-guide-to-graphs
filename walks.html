<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>The Hitchhiker’s Guide to Graphs - 2&nbsp; The Minotaur’s Labyrinth</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./connectivity.html" rel="next">
<link href="./intro.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/quarto-contrib/fontawesome6-0.1.0/all.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/fontawesome6-0.1.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./walks.html">Navigating</a></li><li class="breadcrumb-item"><a href="./walks.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Minotaur’s Labyrinth</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">The Hitchhiker’s Guide to Graphs</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Navigating</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./walks.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Minotaur’s Labyrinth</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./connectivity.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Behind Enemy Lines</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appendix-core.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">The <code>hitchhiker-graphs</code> Python Package</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#modelling-the-labyrinth" id="toc-modelling-the-labyrinth" class="nav-link active" data-scroll-target="#modelling-the-labyrinth">Modelling the labyrinth</a></li>
  <li><a href="#walking-through-a-graph" id="toc-walking-through-a-graph" class="nav-link" data-scroll-target="#walking-through-a-graph">Walking through a graph</a>
  <ul class="collapse">
  <li><a href="#all-trails-contain-a-path" id="toc-all-trails-contain-a-path" class="nav-link" data-scroll-target="#all-trails-contain-a-path"><i class="fa-solid fa-subscript" aria-label="subscript"></i> All trails contain a path</a></li>
  </ul></li>
  <li><a href="#graph-traversal" id="toc-graph-traversal" class="nav-link" data-scroll-target="#graph-traversal">Graph traversal</a></li>
  <li><a href="#depth-first-search" id="toc-depth-first-search" class="nav-link" data-scroll-target="#depth-first-search">Depth-first search</a>
  <ul class="collapse">
  <li><a href="#programming-dfs" id="toc-programming-dfs" class="nav-link" data-scroll-target="#programming-dfs"><i class="fa-solid fa-laptop-code" aria-label="laptop-code"></i> Programming DFS</a></li>
  </ul></li>
  <li><a href="#breadth-first-search" id="toc-breadth-first-search" class="nav-link" data-scroll-target="#breadth-first-search">Breadth-first search</a>
  <ul class="collapse">
  <li><a href="#programming-bfs" id="toc-programming-bfs" class="nav-link" data-scroll-target="#programming-bfs"><i class="fa-solid fa-laptop-code" aria-label="laptop-code"></i> Programming BFS</a></li>
  </ul></li>
  <li><a href="#finding-your-way-out" id="toc-finding-your-way-out" class="nav-link" data-scroll-target="#finding-your-way-out">Finding your way out</a>
  <ul class="collapse">
  <li><a href="#computing-paths" id="toc-computing-paths" class="nav-link" data-scroll-target="#computing-paths"><i class="fa-solid fa-laptop-code" aria-label="laptop-code"></i> Computing paths</a></li>
  </ul></li>
  <li><a href="#other-graph-traversal-strategies" id="toc-other-graph-traversal-strategies" class="nav-link" data-scroll-target="#other-graph-traversal-strategies">Other graph traversal strategies</a>
  <ul class="collapse">
  <li><a href="#random-walk" id="toc-random-walk" class="nav-link" data-scroll-target="#random-walk">Random walk</a></li>
  <li><a href="#bidirectional-search" id="toc-bidirectional-search" class="nav-link" data-scroll-target="#bidirectional-search">Bidirectional search</a></li>
  </ul></li>
  <li><a href="#final-remarks" id="toc-final-remarks" class="nav-link" data-scroll-target="#final-remarks">Final remarks</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./walks.html">Navigating</a></li><li class="breadcrumb-item"><a href="./walks.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Minotaur’s Labyrinth</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Minotaur’s Labyrinth</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/labyrinth.jpeg" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
<p><em>Ariadne was an explorer who loved to seek out ancient mysteries and hidden secrets. She had heard of a legendary labyrinth in Crete, where a fearsome beast called the Minotaur lurked. Many brave adventurers had entered the maze, hoping to slay the monster or find the treasure hidden within, but none had ever returned.</em></p>
<p><em>Ariadne was not afraid, for she was well-versed in the arcane knowledge of graph traversal algorithms! She knew she had two options: going depth-first or breadth-first, and she was debating what was her best chance.</em></p>
<p><em>Going depth-first would mean walking deep into the maze for as long as possible, until she would hit a wall, and then backtrack her steps to find an alternative route. Going breadth-first was just the opposite, she would peek at each possible way just long enough to reach the next intersection, carefully marking the walls of the already explored paths –all adventurers travel with a bag full of chalk, you know?.</em></p>
<p><em>Depth-first was potentially faster, but could lead here right into a deadly trap or get her stuck in a loop if she wasn’t paying attention. Breadth-first was safer but extremely painstaking. So she decided to go in depth, as it would allow her to go deeper into the maze and find the most interesting paths. She hoped to find the Minotaur’s lair and then exit, before her bag of chalks ran out.</em></p>
<p><em>However, she soon realized that the labyrinth was more complex and dangerous than she had imagined. It was full of traps, dead ends, and loops. She also heard the Minotaur’s roars getting closer, as it followed her scent. She wondered if she had made a mistake by choosing depth-first exploration, but it was too late to switch. Now all she could do was hope to find the exit before the Minotaur could found her.</em></p>
<p><em>Will Ariadne escape the labyrinth, or will she face her doom like all previous adventurers? Is depth-first the best option for her exploration, or could she have tried a different algorithm? Let’s find out!</em></p>
<section id="modelling-the-labyrinth" class="level2">
<h2 class="anchored" data-anchor-id="modelling-the-labyrinth">Modelling the labyrinth</h2>
<p>The first step in solving any problem with graphs is, well, turning that problem into a graph problem!</p>
<p>In this case, what we must do is find a way out of the labyrinth, so we must decide how to model the labyrinth as a graph such that nodes and edges map to concepts in the labyrinth that are useful for this task. Since this is our first encounter with graph problems, this will not prove difficult. The most natural mapping, and the one you’re probably thinking about, is using edges to model the corridors in the labyrinth, and nodes to model the intersections.</p>
<p>A possible graph that models a labyrinth is the following:</p>
<div id="89629132" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div>
<figure class="figure">
<p><img src="walks_files/figure-html/cell-2-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>In this model, the solution to our problem –finding a way out of the labyrinth– translates into finding a sequence of nodes, each adjacent to next, that take us from the start <code>0,0</code> to the end <code>6,6</code>.</p>
<p>Let’s begin by formalizing this notion of “walking” through the graph, and then review the most important algorithms that will free Ariadne from the Minotaur.</p>
</section>
<section id="walking-through-a-graph" class="level2">
<h2 class="anchored" data-anchor-id="walking-through-a-graph">Walking through a graph</h2>
<p>The most important structure in a graph is a sequence of connected vertices. This is called a <strong>walk</strong> in the general case, where the only restriction is that between any pair of consecutive vertices there is an edge. For example, <span class="math inline">\(a,b,a,e,c,d\)</span> is a valid walk in our example graph, that happens to go though all vertices, but this, of course, isn’t necessary. Notice that we can move over the same edge back and forth as we want, so we can extend any walk infinitely.</p>
<p>If we never repeat an edge, either backtracking or by making a loop, then we have a <strong>trail</strong>. The previous walk is not a trail because we backtrack through <span class="math inline">\(ab\)</span>. In contrast, <span class="math inline">\(a,b,e,d, e\)</span> is a valid trail in our example graph, because although <span class="math inline">\(e\)</span> appears twice, we get to it via different edges each time.</p>
<p>Finally, if we also never repeat a vertex, then we have a <strong>path</strong> (some literature will use <em>path</em> to refer to what we call a <em>trail</em>, and <em>simple path</em> to refer to a path with no repeated vertices). In our example graph, <span class="math inline">\(a,b,d,c,e\)</span> is a path that happens to involve all vertices. If, like in the previous case, the path can loop over from the final vertex back into the first one, then we call it a <strong>cycle</strong>.</p>
<section id="all-trails-contain-a-path" class="level3">
<h3 class="anchored" data-anchor-id="all-trails-contain-a-path"><i class="fa-solid fa-subscript" aria-label="subscript"></i> All trails contain a path</h3>
<p>You might have noticed that the difference between trails and path is that trails can have small sub-cycles inside them. Intuitively, every time we find one such cycle, we can skip it and continue directly in the “main path”. Thus, it makes sense to think that we can always remove all detours from a trail and extract a path that begins and ends in the same vertices.</p>
<p>If we can get from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span> at all, then we must be able to get from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span> without making any unnecessary loops, right? The answer is yes, of course. This is our first theorem, and one we will use often in the rest of the book.</p>
<hr>
<p><strong>Theorem 1:</strong> In any graph <span class="math inline">\(G\)</span>, if there is a trail from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span>, then there is a path from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span>.</p>
<hr>
<p><strong>Proof:</strong> Here is one intuitive, but rigorous demonstration for Theorem 1. We will use something called the <em>well-ordering principle</em><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, a fundamental axiom of natural numbers that basically says, if you have a non-empty set of discrete things that have some property you can use to compare them –like a size–, there is one them that is the smallest.</p>
<p>In this case, we will consider the set of all possible trails between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. Since, by the condition of the theorem, there exists a trail from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span>, we know this is a non-empty set. Then we can invoke the well-ordering principle and ask for the smallest possible such trail. Our claim, is that the shortest trail between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> must be a path. Why? Here we will use another fundamental tool of logical reasoning: <em>proof by contradiction</em><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>Suppose the shortest trail between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> is not a path. Then, it must contain some internal loop, for otherwise it would be a path and the proof would be done. Thus, if it contains a loop, we can make the trail shorter by removing that loop, and it will still fo from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span>. This is in contradiction with the claim that we had the shortest possible trail. Thus, by <em>reductio ad absurdum</em>, <strong>the shortest trail must be a path</strong>.</p>
<p>The proof is almost complete. The only step we slightly overlooked is the claim that the existence of a loop implies that we can make the trail shorter. To airtight this part of the proof, we need to show how to actually construct that shortest trail.</p>
<p>Let <span class="math inline">\(P=a \rightarrow^n b\)</span> be the shortest trail between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, with length (number of edges) <span class="math inline">\(n=|P|-1\)</span>. Assume this trail has a loop, thus, there is some vertex, call it <span class="math inline">\(x\)</span>, that appears twice inside the trail (<span class="math inline">\(x\)</span> could very well be <span class="math inline">\(a\)</span>, or <span class="math inline">\(b\)</span>, but for the sake of generalization we can assume it’s somewhere inside). Thus, the <span class="math inline">\(P\)</span> trail actually looks like this:</p>
<p><span class="math display">\[P=a \rightarrow^{k_{1}} x^{(1)} \rightarrow^{k_{2}} x^{(2)} \rightarrow^{k_{3}} b\]</span></p>
<p>where <span class="math inline">\(x^{(i)}\)</span> indicates the <span class="math inline">\(i\)</span>-th time the vertex <span class="math inline">\(x\)</span> appears, and <span class="math inline">\(k_{1}+k_{2}+k_{3}=n\)</span>, with <span class="math inline">\(k_{1}\geq 0\)</span>, <span class="math inline">\(k_{2}&gt; 0\)</span>, and <span class="math inline">\(k_{3} \geq 0\)</span>. That is, the part between <span class="math inline">\(x^{(1)}\)</span> and <span class="math inline">\(x^{(2)}\)</span> must have at least one edge (in fact, it must have at least length <span class="math inline">\(2\)</span>, but we don’t need that).</p>
<p>Now we need to construct a valid trail from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span> that is strictly smaller than <span class="math inline">\(n\)</span>. We can make a trail by going from <span class="math inline">\(a\)</span> to some vertex <span class="math inline">\(v\)</span> and then from <span class="math inline">\(v\)</span> to <span class="math inline">\(b\)</span>. In trail <span class="math inline">\(P\)</span> we have two trails <span class="math inline">\(a \rightarrow^{k_1} x\)</span> and <span class="math inline">\(x \rightarrow^{k_2} b\)</span> that we can stitch together and make a new trail <span class="math inline">\(P’ = a  \rightarrow^{k_1+k_3} b\)</span>, where the length of <span class="math inline">\(P’\)</span> (equal to <span class="math inline">\(k_1+k_3\)</span>) must be strictly less than <span class="math inline">\(n\)</span> because <span class="math inline">\(k_2 &gt; 0\)</span>. <span class="math inline">\(\blacksquare\)</span></p>
</section>
</section>
<section id="graph-traversal" class="level2">
<h2 class="anchored" data-anchor-id="graph-traversal">Graph traversal</h2>
<p>The simplest procedure in graphs that involves some notion of “walking” is graph traversal. This is the task of enumerating all nodes in a predefined order by moving through the edges. That is, we don’t want to simply list all nodes –that is trivial– but to do so in a way that uses the graph structure, such that adjacent nodes are considered next to each other.</p>
<p>There are two basic graph traversal algorithms: depth-first search (DFS) and breadth-first search (BFS). Both algorithms are very similar, and will produce a full enumeration of a graph –assuming all nodes are reachable, which is a question we’ll answer next chapter. They differ in how they prioritize being eager versus being comprehensive.</p>
<section id="abstract-traversals" class="level4">
<h4 class="anchored" data-anchor-id="abstract-traversals"><i class="fa-solid fa-laptop-code" aria-label="laptop-code"></i> Abstract traversals</h4>
<p>We will begin by defining how our abstract notion of “search” looks like. To keep things simple, we assume a search algorithm provides a single method <code>traverse</code> that simply enumerates all edges in the order in which they are discovered.</p>
<!-- SNIPPET search.py @search @search-extra -->
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Search(Generic[T], ABC):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">@abstractmethod</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> traverse(<span class="va">self</span>, graph: Graph[T], root: T):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> nodes(<span class="va">self</span>, graph: Graph[T], root: T):</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (y <span class="cf">for</span> (x,y) <span class="kw">in</span> <span class="va">self</span>.traverse(graph, root))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... extra methods in Search</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<i class="fa-brands fa-github" aria-label="github"></i> See on Github: <a href="https://github.com/apiad/graphs/blob/main/graphs/search.py#L34-L42" class="uri">https://github.com/apiad/graphs/blob/main/graphs/search.py#L34-L42</a>
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<!-- /SNIPPET -->
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>The <code>nodes</code> method is just a thing wrapper around <code>traverse</code> that yields the nodes instead the full edges.</p>
</div>
</div>
<p>Why make this a class? Isn’t this just a method? Well, it’s a bit of mouthful at the moment, for sure. But later, as we explore many search strategies, we’ll want to compare different search strategies, and it will become useful to have a class for each of them.</p>
<p>Plus, this abstract method allows us to implement a very common search pattern that we will reuse over and over: searching for an specific set of nodes (or a single node). We can have the general-purpose case that matches any node with a given property, and the special case when we need to find one particular node –e.g., like the exit of the labyrinth.</p>
<!-- SNIPPET search.py @search-extra @search-extra-2 -->
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># class Search(...)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">#   ...</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find_any(<span class="va">self</span>, graph: Graph[T], origin: T, goal: Callable[[T], <span class="bu">bool</span>]):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node <span class="kw">in</span> <span class="va">self</span>.traverse(graph, origin):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> goal(node):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find(<span class="va">self</span>, graph: Graph[T], origin: T, destination: T):</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.find_any(graph, origin, goal<span class="op">=</span><span class="kw">lambda</span> n: n <span class="op">==</span> destination)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<i class="fa-brands fa-github" aria-label="github"></i> See on Github: <a href="https://github.com/apiad/graphs/blob/main/graphs/search.py#L45-L56" class="uri">https://github.com/apiad/graphs/blob/main/graphs/search.py#L45-L56</a>
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<!-- /SNIPPET -->
<p>With this code in place, we’re ready for some actual search algorithms.</p>
</section>
</section>
<section id="depth-first-search" class="level2">
<h2 class="anchored" data-anchor-id="depth-first-search">Depth-first search</h2>
<p>As the name implies, depth-first search (DFS) is a graph traversal algorithm that prioritizes going as deep as possible as fast as possible. In our labyrinth analogy, this means walking down a corridor till you can’t go any further, and only then, when you reach a dead end, you backtrack and try a different route.</p>
<p>More precisely, DFS starts at an arbitrary root node in a graph, and successively jumps to one of its neighbors, and continues from there. You can select which neighbor to visit randomly, but most commonly one simply defines a predefined order –e.g., the same order in which neighbors are listed in the adjacency list. In a practical scenario, like our labyrinth, this could mean, for example, always trying to move south, then east, then north, then west. Of course, you must keep track of which nodes (or intersections in the labyrinth) you have already visited, otherwise you can easily get stuck in a loop.</p>
<p>This is how DFS looks like in our sample graph that models the labyrinth problem.</p>
<div id="623bd95c" class="cell" data-execution_count="2">
<div class="cell-output cell-output-display" data-execution_count="2">
<div>
<figure class="figure">
<p><img src="walks_files/figure-html/cell-3-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Understanding this image
</div>
</div>
<div class="callout-body-container callout-body">
<p>In the previous image, we label each node with a number that indicates the order in which it is discovered by DFS. Thus, nodes that have consecutive numbers indicate that DFS traveled along that path. When you see two adjancent nodes with non-consecutive numbers, that means DFS backtracked to that node after getting stuck, and took a different path.</p>
</div>
</div>
<section id="programming-dfs" class="level3">
<h3 class="anchored" data-anchor-id="programming-dfs"><i class="fa-solid fa-laptop-code" aria-label="laptop-code"></i> Programming DFS</h3>
<p>Now let’s implement DFS. The easiest implementation is using recursion: we start at the root node and recursively visit all non-visited neighbors. To make sure we don’t get stuck in a loop, we can use a set to keep track of visited nodes throughout all the recursive calls. Each iteration, we return the edge <span class="math inline">\((x,y)\)</span> where <span class="math inline">\(y\)</span> is the current node under consideration, and <span class="math inline">\(x\)</span> is the “parent” node –that we must also keep track of during recursion.</p>
<p>Here is the full implementation:</p>
<!-- SNIPPET search.py @dfs @dfs-end -->
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DFS(Search[T]):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> traverse(<span class="va">self</span>, graph: Graph[T], root: T):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._dfs(graph, root, <span class="va">None</span>, <span class="bu">set</span>())</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _dfs(<span class="va">self</span>, graph: Graph[T], current: T, parent:T, visited: Set[T]):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> parent, current</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        visited.add(current)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node <span class="kw">in</span> graph.neighborhood(current):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node <span class="kw">in</span> visited:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> <span class="cf">from</span> <span class="va">self</span>._dfs(graph, node, current, visited)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<i class="fa-brands fa-github" aria-label="github"></i> See on Github: <a href="https://github.com/apiad/graphs/blob/main/graphs/search.py#L73-L85" class="uri">https://github.com/apiad/graphs/blob/main/graphs/search.py#L73-L85</a>
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<!-- /SNIPPET -->
<p>As it’s common in recursive methods, we have a public “portal” method that exposes the public arguments, which in turn defers to a private implementation that takes any additional arguments we need for bookkeeping.</p>
</section>
</section>
<section id="breadth-first-search" class="level2">
<h2 class="anchored" data-anchor-id="breadth-first-search">Breadth-first search</h2>
<section id="programming-bfs" class="level3">
<h3 class="anchored" data-anchor-id="programming-bfs"><i class="fa-solid fa-laptop-code" aria-label="laptop-code"></i> Programming BFS</h3>
</section>
</section>
<section id="finding-your-way-out" class="level2">
<h2 class="anchored" data-anchor-id="finding-your-way-out">Finding your way out</h2>
<section id="computing-paths" class="level3">
<h3 class="anchored" data-anchor-id="computing-paths"><i class="fa-solid fa-laptop-code" aria-label="laptop-code"></i> Computing paths</h3>
<p>While knowing that a goal node exists is useful, we often want to find the actual path that takes us there. Fortunately, our abstract <code>Search</code> strategy can implement this operation easily using the <code>parent -&gt; node</code> information available in each iteration in the <code>traverse</code> method.</p>
<p>To quickly compute paths, we can define a simple structure (<code>Paths</code>) that stores a reference to the parent of each node found during search. With this information, the path between our origin vertex and an arbitrary destination is easy to compute by following the links backwards. That is, we start at the destination node, and iteratively add the parent node to a list, until we find the origin node. Then, we simply reverse the list.</p>
<!-- SNIPPET search.py @paths @paths-end -->
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Paths(Generic[T]):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, origin:T) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._parents <span class="op">=</span> {}</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.origin <span class="op">=</span> origin</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add(<span class="va">self</span>, node, parent):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">in</span> <span class="va">self</span>._parents:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Node already exists"</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._parents[node] <span class="op">=</span> parent</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> path(<span class="va">self</span>, destination) <span class="op">-&gt;</span> <span class="bu">list</span>[T]:</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        path <span class="op">=</span> [destination]</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> destination</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node <span class="op">!=</span> <span class="va">self</span>.origin:</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>._parents[node]</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            path.append(node)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        path.reverse()</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> path</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<i class="fa-brands fa-github" aria-label="github"></i> See on Github: <a href="https://github.com/apiad/graphs/blob/main/graphs/search.py#L9-L29" class="uri">https://github.com/apiad/graphs/blob/main/graphs/search.py#L9-L29</a>
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<!-- /SNIPPET -->
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Paths are origin-dependent
</div>
</div>
<div class="callout-body-container callout-body">
<p>You’ll notice we don’t require an <code>origin</code> parameter in the <code>Paths.path</code> method. That is because this structure holds paths precomputed from a fixed origin node, that is, the node from which the search algorithm started.</p>
<p>If you need to precompute paths for arbitrary pairs of nodes, there is little you can do other than using a <code>Path</code> instance for each origin node.</p>
</div>
</div>
<p>With this structure in place, we can add a method to the <code>Search</code> class to compute all paths for a given graph and origin.</p>
<!-- SNIPPET search.py @search-extra-2 @search-end -->
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># class Search(...)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">#   ...</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_paths(<span class="va">self</span>, graph: Graph[T], origin:T) <span class="op">-&gt;</span> Paths[T]:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        paths <span class="op">=</span> Paths(origin)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> parent, node <span class="kw">in</span> <span class="va">self</span>.traverse(graph, origin):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            paths.add(node, parent)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> paths</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<i class="fa-brands fa-github" aria-label="github"></i> See on Github: <a href="https://github.com/apiad/graphs/blob/main/graphs/search.py#L59-L68" class="uri">https://github.com/apiad/graphs/blob/main/graphs/search.py#L59-L68</a>
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<!-- /SNIPPET -->
</section>
</section>
<section id="other-graph-traversal-strategies" class="level2">
<h2 class="anchored" data-anchor-id="other-graph-traversal-strategies">Other graph traversal strategies</h2>
<section id="random-walk" class="level3">
<h3 class="anchored" data-anchor-id="random-walk">Random walk</h3>
</section>
<section id="bidirectional-search" class="level3">
<h3 class="anchored" data-anchor-id="bidirectional-search">Bidirectional search</h3>
</section>
</section>
<section id="final-remarks" class="level2">
<h2 class="anchored" data-anchor-id="final-remarks">Final remarks</h2>
<p>DFS and BFS are the two cornerstones of graph search. Almost all algorithms in this book will either include one of these as an explicit step, or use them as building block.</p>


</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>See <a href="https://en.wikipedia.org/wiki/Well-ordering_principle">https://en.wikipedia.org/wiki/Well-ordering_principle</a>.</p>
<p>Technically, we don’t need the full well-ordering principle in this proof because we have a <em>finite set</em> of things, so of course one of them must be the smallest. The well-ordering principle applies also to infinite sets, which is where it becomes really handy.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://thepalindrome.org/p/proof-by-induction-and-contradiction">https://thepalindrome.org/p/proof-by-induction-and-contradiction</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./intro.html" class="pagination-link" aria-label="Introduction">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./connectivity.html" class="pagination-link" aria-label="Behind Enemy Lines">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Behind Enemy Lines</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>